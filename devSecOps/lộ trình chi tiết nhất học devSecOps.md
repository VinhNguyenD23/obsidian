
| Giai đoạn                           | Hạng mục                            | Mô tả                                                                             | Ví dụ cụ thể                                                                                                                              | Cách tư duy (Thinking Process)                                                                                                                                                              | Cách trả lời (How to Answer)                                                                                                                                                                                       | Góc nhìn DevSecOps                                                                                                                                                                                            |
| ----------------------------------- | ----------------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Phase 1: Nền tảng & Monolith        | 1. Core Principles (Non-Functional) | Các yêu cầu phi chức năng quyết định kiến trúc.                                   | Một trang TMĐT cần response dưới 200ms và uptime 99.99%.                                                                                  | "Hệ thống cần nhanh (Performance), đáng tin cậy (Reliability), hay luôn sẵn sàng (Availability)? Trade-off là gì? Uptime 99.99% đắt hơn 99.9% rất nhiều."                                   | "Chúng ta cần làm rõ các yêu cầu phi chức năng. Ví dụ, hệ thống này ưu tiên Consistency hay Availability (theo CAP Theorem)? Mục tiêu RPO/RTO là bao nhiêu?"                                                       | Bảo mật là yêu cầu phi chức năng (non-functional) cốt lõi. Phải xác định mô hình rủi ro (Threat Model) ngay từ đầu. Ai có thể tấn công? Tấn công vào đâu?                                                     |
| Phase 1: Nền tảng & Monolith        | 2. Thiết kế Monolith (Layered)      | Một khối ứng dụng duy nhất, thường phân tầng (Controller, Service, Repository).   | Một blog đơn giản dùng NestJS + Postgres, deploy trên 1 server duy nhất.                                                                  | "Làm thế nào để cấu trúc code rõ ràng? (Controller→Service→Repo). Làm sao để deploy đơn giản nhất? (Một Git repo, một build artifact)."                                                     | "Bắt đầu với Monolith là hợp lý để phát triển nhanh (rapid iteration). Chúng ta sẽ dùng kiến trúc phân tầng (Layered Architecture) để tách biệt logic (separation of concerns)."                                   | Giảm thiểu Attack Surface. Vì là một khối, nên validate input (DTO) là cực kỳ quan trọng. Dùng Helmet (user memory) để set các security headers cơ bản. Log tập trung (Pino).                                 |
| Phase 1: Nền tảng & Monolith        | 3. Database (Monolith)              | Thường dùng 1 DB quan hệ (SQL) cho toàn bộ ứng dụng.                              | Blog trên dùng DB Postgres, có bảng users, posts, comments.                                                                               | "Dữ liệu có quan hệ phức tạp không? Cần transaction mạnh không? (User memory: ưu tiên Postgres + transaction) -> Chọn SQL. Cần schema rõ ràng."                                             | "Sử dụng CSDL quan hệ như Postgres để đảm bảo tính ACID, đặc biệt khi các nghiệp vụ (vd: user và post) liên kết chặt chẽ với nhau."                                                                                | Bảo vệ dữ liệu (Data Protection). Không bao giờ lưu password dạng plaintext (dùng Argon2 - user memory). Dữ liệu nhạy cảm (PII) phải được mã hóa (at-rest & in-transit). Database migration phải được review. |
| Phase 1: Nền tảng & Monolith        | 4. Caching (Bộ đệm)                 | Tăng tốc độ đọc (read) bằng cách lưu dữ liệu hay dùng vào RAM (ví dụ: Redis).     | Cache thông tin user profile hoặc bài post "hot" vào Redis.                                                                               | "Query nào tốn kém nhất? Dữ liệu nào ít thay đổi nhưng được đọc nhiều? -> Đẩy nó lên Cache. Cache bị 'trôi' (stale) thì sao? Chiến lược cache invalidation là gì (TTL, write-through)?"     | "Để giảm tải cho DB và tăng tốc độ phản hồi, chúng ta sẽ implement caching. Ví dụ: dùng Redis (cache-aside pattern) để cache các dữ liệu profile user trong 5 phút."                                               | Bảo mật Cache. Cache có thể chứa dữ liệu nhạy cảm. Đảm bảo Redis được bảo vệ (password, network policies), không public. Cẩn thận với Cache Poisoning (đầu độc cache).                                        |
| Phase 2: Mở rộng Monolith           | 5. Vertical vs. Horizontal Scaling  | Tăng năng lực xử lý. Vertical (thêm CPU/RAM). Horizontal (thêm máy chủ).          | Vertical: Nâng cấp server từ 2-core lên 8-core. Horizontal: Chạy 3 instance của con Monolith.                                             | "App bị chậm do CPU hay RAM? (Vertical). App bị chậm do quá nhiều request đồng thời? (Horizontal). Horizontal scaling rẻ hơn nhưng phức tạp hơn."                                           | "Hệ thống đang gặp bottleneck. Chúng ta sẽ scale theo chiều ngang (Horizontal) bằng cách chạy 3 instances của app, vì nó linh hoạt và rẻ hơn Vertical scaling."                                                    | Scaling và Security. Scale ngang đồng nghĩa với việc quản lý nhiều "bí mật" (secrets) hơn. Cần một hệ thống quản lý config/secrets tập trung (như HashiCorp Vault hoặc Env schema-validated).                 |
| Phase 2: Mở rộng Monolith           | 6. Load Balancer (LB)               | Phân phối traffic đến các instance của app (khi đã scale ngang).                  | Dùng Nginx làm LB, chia request (Round Robin) cho 3 instance NestJS.                                                                      | "Khi có 3 instance, làm sao client biết gọi vào đâu? Làm sao biết 1 instance 'chết'? -> Cần một 'cổng' (LB) đứng trước. LB sẽ làm luôn health check."                                       | "Chúng ta sẽ đặt một Load Balancer (ví dụ: Nginx) trước 3 app instances. LB sẽ phân phối traffic và thực hiện health checks, tự động loại bỏ node lỗi ( đảm bảo HA)."                                              | LB là tuyến phòng thủ đầu tiên. Thực hiện SSL/TLS Termination tại LB. Áp dụng Rate Limiting (user memory) và WAF (Web App Firewall) tại đây để chặn DDoS, SQLi cơ bản.                                        |
| Phase 2: Mở rộng Monolith           | 7. Database Scaling (Read Replicas) | Tách biệt việc đọc (READ) và ghi (WRITE) để giảm tải cho DB chính.                | Tạo 1 DB Postgres (Replica) chỉ cho việc đọc (vd: các trang dashboard, report).                                                           | "Tỷ lệ Read/Write là bao nhiêu? Nếu 90% là Read, DB chính (Master) đang quá tải. -> Tạo bản sao (Replica) chỉ cho Read. Dữ liệu ở Replica có thể trễ (replication lag)."                    | "Để tối ưu DB, chúng ta sẽ dùng Read Replicas. Mọi query SELECT sẽ trỏ vào Replica, còn INSERT/UPDATE/DELETE trỏ vào Master. Cần xử lý vấn đề replication lag."                                                    | Quản lý kết nối an toàn. App service phải có 2 connection string (Master, Replica) với quyền hạn (permissions) khác nhau. User của Replica chỉ được SELECT.                                                   |
| Phase 2: Mở rộng Monolith           | 8. Message Queue (MQ) / Async       | Xử lý các tác vụ tốn thời gian (vd: gửi email, resize ảnh) một cách bất đồng bộ.  | User đăng ký -> Ghi vào DB (Sync) -> Đẩy message "SendWelcomeEmail" vào RabbitMQ (Async).                                                 | "Tác vụ nào user không cần chờ kết quả ngay? (Gửi email). Nếu làm đồng bộ, request sẽ bị 'treo' lâu. -> Tách nó ra. Worker sẽ xử lý sau."                                                   | "Các tác vụ nặng như gửi email, chúng ta sẽ dùng Message Queue (RabbitMQ). API chỉ cần publish message (độ trễ < 5ms) và trả về 202 Accepted cho user ngay lập tức."                                               | Bảo mật Message. Ai được phép publish/subscribe vào queue? Message có chứa dữ liệu nhạy cảm không? (Nếu có, phải mã hóa nội dung message). Xử lý message thất bại (Dead Letter Queue - DLQ).                  |
| Phase 3: Chuyển đổi (Microservices) | 9. Decomposition (Chia tách)        | Quyết định chia Monolith như thế nào. Thường theo Domain-Driven Design (DDD).     | App TMĐT Monolith -> Tách thành: UserService, ProductService, OrderService.                                                               | "Nghiệp vụ (domain) nào có thể đứng độc lập? (User và Product). Dữ liệu nào thuộc về ai? (OrderService sở hữu 'Order'). Đây là các Bounded Contexts."                                       | "Chúng ta sẽ áp dụng DDD để chia Monolith. Dựa trên Bounded Context, chúng ta xác định các services: User, Product, Order. Mỗi service sẽ sở hữu database riêng của nó."                                           | Tăng Attack Surface. Từ 1 app thành 3 app -> 3 điểm có thể bị tấn công. Mỗi service phải tự xác thực (AuthN) và phân quyền (AuthZ). Không tin tưởng lẫn nhau (Zero Trust).                                    |
| Phase 3: Chuyển đổi (Microservices) | 10. API Gateway                     | Một cổng duy nhất cho mọi request từ client. Định tuyến đến service tương ứng.    | Client (Mobile App) chỉ gọi api.example.com. Gateway sẽ: /users/* -> UserService, /products/* -> ProductService.                          | "Client (app) có phải gọi 3 API khác nhau không? (Quá phức tạp). Làm sao xử lý AuthN/AuthZ/Rate Limit tập trung? -> Cần API Gateway."                                                       | "Sử dụng API Gateway (vd: Kong, Ocelot) làm điểm vào duy nhất. Gateway sẽ chịu trách nhiệm routing, authentication (JWT validation), và rate limiting."                                                            | Gateway là điểm chốt bảo mật quan trọng. Nó phải validate mọi request. Dễ trở thành điểm nghẽn (Single Point of Failure). Áp dụng AuthZ theo scope (vd: JWT scope 'order:create').                            |
| Phase 3: Chuyển đổi (Microservices) | 11. Inter-Service Communication     | Cách các service nói chuyện với nhau (Sync vs. Async).                            | Sync: OrderService gọi ProductService qua (gRPC/REST) để kiểm tra giá. Async: OrderService phát event OrderCreated lên Kafka.             | "Service A có cần dữ liệu ngay lập tức từ Service B không? (Sync - gRPC). Hay Service A chỉ cần thông báo cho Service B? (Async - Message Bus). Async giúp giảm khớp nối (loose coupling)." | "Chúng ta ưu tiên giao tiếp Async (Event-Driven) qua Kafka/RabbitMQ để tăng tính kiên cường (resilience). Chỉ dùng Sync (gRPC) khi bắt buộc phải có dữ liệu ngay."                                                 | Sync (gRPC/REST): Cần cơ chế mTLS (Mutual TLS) để 2 service xác thực lẫn nhau. Async (Kafka): Ai được quyền đọc/ghi vào topic nào? (ACLs).                                                                    |
| Phase 4: Vận hành Microservices     | 12. Data Consistency (Saga)         | Đảm bảo nghiệp vụ nhất quán qua nhiều service (thay thế cho DB transaction).      | User đặt hàng: 1. OrderService (Create Order) -> 2. PaymentService (Process Payment) -> 3. StockService (Decrease Stock).                 | "Nếu bước 2 (Payment) fail thì sao? Bước 1 (Order) đã lỡ tạo. Không thể dùng DB transaction. -> Phải có cơ chế 'rollback' (Compensating Transaction) -> Saga Pattern."                      | "Sử dụng Saga Pattern (Orchestration hoặc Choreography) để quản lý transaction phân tán. Nếu PaymentService thất bại, nó sẽ phát event 'PaymentFailed' để OrderService chạy compensating transaction (hủy Order)." | Phức tạp về tracing. Cực kỳ cần Correlation ID (user memory) để theo dõi 1 request đi qua 3-4 service. Phải log trạng thái của Saga cẩn thận để debug khi lỗi.                                                |
| Phase 4: Vận hành Microservices     | 13. Distributed Tracing / Logging   | Theo dõi một request qua nhiều service. Log tập trung.                            | Dùng (Jaeger/Zipkin) + (ELK/Loki).                                                                                                        | "Một request fail, làm sao biết nó fail ở service nào trong 5 service? Log đang nằm rải rác ở 5 nơi. -> Cần 1 ID chung (Correlation ID) và một nơi xem log tập trung."                      | "Implement Centralized Logging (ELK Stack) và Distributed Tracing (Jaeger). Mọi log phải tuân thủ structured logging (JSON) và chứa Correlation ID."                                                               | Không log secrets (user memory). Log phải được lọc (sanitize) để không lộ PII, API keys, tokens. Đảm bảo nhân viên support chỉ thấy log họ cần (RBAC for logs).                                               |
| Phase 4: Vận hành Microservices     | 14. Service Discovery & Config      | Làm sao Service A biết IP của Service B (khi B có thể scale/chết bất cứ lúc nào)? | OrderService hỏi Consul (hoặc Kubernetes DNS): "IP của ProductService là gì?"                                                             | "Không thể hardcode IP. Service B có thể có 3 instance, IP động. -> Cần một 'danh bạ điện thoại' (Service Discovery) tự động cập nhật."                                                     | "Các service sẽ tự đăng ký với Service Discovery (Consul) khi khởi động. Khi cần gọi nhau, chúng sẽ query Consul. Config sẽ được quản lý tập trung tại Config Server."                                             | Bảo mật Config Server. Đây là nơi chứa "chìa khóa vương quốc" (DB passwords, API keys). Phải được mã hóa, kiểm soát truy cập nghiêm ngặt. Phải có audit log (ai đọc config gì).                               |
| Phase 4: Vận hành Microservices     | 15. Resiliency (Circuit Breaker)    | Ngăn chặn lỗi dây chuyền (cascading failure).                                     | OrderService gọi PaymentService. PaymentService bị chậm. OrderService 'mở cầu dao' (open circuit), ngừng gọi PaymentService trong 5 phút. | "Nếu PaymentService (thứ yếu) bị sập, nó có kéo sập OrderService (chủ chốt) không? (Do OrderService tốn thread để chờ). -> Phải có cơ chế 'ngắt' (Circuit Breaker)."                        | "Áp dụng Circuit Breaker Pattern. Nếu 50% request tới PaymentService thất bại, 'cầu dao' sẽ mở trong 1 phút, OrderService sẽ trả về lỗi ngay lập tức (fail fast) thay vì chờ."                                     | Operations (Vận hành). Phải monitor trạng thái của Circuit Breaker (Open/Closed/Half-Open). Alert ngay khi 'cầu dao' mở, vì đây là dấu hiệu hệ thống đang bất ổn.                                             |
| Phase 5: DevSecOps Toàn diện        | 16. CI/CD Pipeline & Security       | Tích hợp bảo mật bên trong đường ống CI/CD.                                       | Pipeline GitLab: Build -> SAST (SonarQube) -> Test (Unit/Integration) -> SCA (Snyk) -> Build Image -> DAST (ZAP) -> Deploy.               | "Làm sao đảm bảo code lỗi (vulnerability) không lên production? -> Quét tự động. Quét code (SAST). Quét thư viện (SCA). Quét app đang chạy (DAST)."                                         | "Pipeline CI/CD của chúng ta sẽ tích hợp SAST, DAST, và SCA. Build sẽ fail nếu phát hiện lỗ hổng nghiêm trọng (critical). Mọi artifact phải được ký số (signed)."                                                  | Đây chính là "Sec" trong "DevSecOps". Tự động hóa bảo mật. Dịch chuyển bảo mật sang trái (Shift-Left Security). Developer chịu trách nhiệm về lỗ hổng của mình.                                               |
| Phase 5: DevSecOps Toàn diện        | 17. Container & Orchestration (K8s) | Đóng gói (Docker) và điều phối (Kubernetes) các microservices.                    | Deploy 3 replica của UserService (Docker image) lên Kubernetes (K8s). K8s tự lo scaling, networking, self-healing.                        | "Làm sao deploy 50 microservices? Làm sao quản lý networking, scaling, update? -> Cần một hệ thống điều phối (Orchestrator) -> Kubernetes (K8s)."                                           | "Chúng ta sẽ container hóa (Docker) mọi service và deploy lên K8s. K8s sẽ quản lý vòng đời, scaling (HPA), và service discovery (CoreDNS)."                                                                        | Bảo mật Container & K8s. Image phải "tối ưu và nhẹ" (user project), không chạy VỚI quyền root (non-root). Dùng Network Policies (trong K8s) để chặn PaymentService gọi UserService.                           |
| Phase 5: DevSecOps Toàn diện        | 18. Monitoring & Alerting           | Giám sát hệ thống (Metrics, Logs, Traces) và cảnh báo khi có sự cố.               | Dùng Prometheus (Metrics) + Grafana (Dashboard) + AlertManager (Cảnh báo).                                                                | "Làm sao biết hệ thống 'khỏe' (healthy)? (Metrics: CPU, RAM, req/s, 5xx errors). Khi có lỗi (vd: 5xx > 1%), làm sao biết ngay? (Alerting)."                                                 | "Chúng ta dùng Prometheus để thu thập metrics (theo chuẩn OpenTelemetry). Grafana để visualize. Cảnh báo (Alerting) sẽ được gửi qua PagerDuty/Slack khi latency > 500ms hoặc tỷ lệ lỗi > 1%."                      | Giám sát bảo mật (Security Monitoring). Ai đó đang cố gắng login thất bại 10 lần? (Alert). Có request lạ từ IP lạ? (Alert). Log immutability (log không thể bị xóa/sửa).                                      |